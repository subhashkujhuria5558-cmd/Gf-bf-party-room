const express = require('express');
const mongoose = require('mongoose');
const jwt = require('jsonwebtoken');
const cors = require('cors');
const bodyParser = require('body-parser');
const http = require('http');
const socketIo = require('socket.io');

const app = express();
const PORT = process.env.PORT || 5000;

// MongoDB URI & JWT SECRET (⚠️ render पर ENV variable में डालना बेहतर है)
const MONGODB_URI = "mongodb+srv://subhashkujhuria5558_db_user:Ywvjtk95zXIdtpGb@cluster0.3bcvs3w.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0";
const JWT_SECRET = "uY7$kd9sPQw!zX@4eF1#Lm8H&Tr3nBv0xZaR6WqTjN2oLg";

app.use(cors());
app.use(bodyParser.json());

// Connect to MongoDB
mongoose.connect(MONGODB_URI, { useNewUrlParser: true, useUnifiedTopology: true })
    .then(() => console.log('MongoDB connected'))
    .catch(e => console.log(e));

// ------------------- User Schema -------------------
const userSchema = new mongoose.Schema({
    username: String,
    email: String,
    passwordHash: String,
    roles: [String],
    balance: Number,
    chips: Number,
    isBlocked: Boolean,
    createdAt: { type: Date, default: Date.now }
});

const User = mongoose.model('User', userSchema);

function authenticateToken(req, res, next) {
    const token = req.headers['authorization']?.split(' ')[1];
    if (!token) return res.status(401).json({ message: 'Token missing' });

    jwt.verify(token, JWT_SECRET, (err, user) => {
        if (err) return res.status(403).json({ message: 'Invalid token' });
        req.user = user;
        next();
    });
}

// ------------------- Routes -------------------

// Register User
app.post('/api/auth/register', async (req, res) => {
    try {
        const { username, email, passwordHash } = req.body;
        const user = new User({ username, email, passwordHash, roles: ['user'], balance: 0, chips: 0, isBlocked: false });
        await user.save();
        res.json({ message: 'User registered' });
    } catch (err) {
        res.status(500).json({ message: 'Registration error' });
    }
});

// Login User
app.post('/api/auth/login', async (req, res) => {
    try {
        const { email, passwordHash } = req.body;
        const user = await User.findOne({ email, passwordHash });
        if (!user) return res.status(401).json({ message: 'Invalid credentials' });
        if (user.isBlocked) return res.status(403).json({ message: 'User blocked' });

        const token = jwt.sign({ id: user._id, roles: user.roles }, JWT_SECRET, { expiresIn: '1d' });
        res.json({ token, username: user.username, roles: user.roles, balance: user.balance, chips: user.chips });
    } catch (err) {
        res.status(500).json({ message: 'Login error' });
    }
});

// Get Logged User Profile
app.get('/api/user/profile', authenticateToken, async (req, res) => {
    try {
        const user = await User.findById(req.user.id);
        res.json({ username: user.username, balance: user.balance, chips: user.chips, roles: user.roles });
    } catch (err) {
        res.status(500).json({ message: 'Profile fetch error' });
    }
});

// Admin: Get all users
app.get('/api/admin/users', authenticateToken, async (req, res) => {
    if (!req.user.roles.includes('admin')) return res.status(403).json({ message: 'Forbidden' });
    const users = await User.find();
    res.json(users);
});

// ------------------- Socket.io Setup -------------------
const server = http.createServer(app);
const io = socketIo(server, {
  cors: {
    origin: '*',
  }
});

// Live Rooms (Memory storage)
let liveRooms = {
  room1: {
    id: 'room1',
    name: 'VIP Room 1',
    seats: Array(8).fill(null),
    lockedSeats: new Set(),
    owner: null,
  }
};

// WebSocket event handlers
io.on('connection', (socket) => {
  console.log('New client connected: ' + socket.id);

  // User joins room
  socket.on('joinRoom', ({ roomId, userId }) => {
    const room = liveRooms[roomId];
    if (!room) return;

    let seatIndex = room.seats.findIndex(s => s === null);
    if (seatIndex === -1) {
      socket.emit('roomFull', roomId);
      return;
    }

    room.seats[seatIndex] = userId;
    socket.join(roomId);

    io.to(roomId).emit('roomUpdate', room);
    socket.data = { roomId, seatIndex, userId };
  });

  // User leaves room
  socket.on('leaveRoom', () => {
    const { roomId, seatIndex } = socket.data || {};
    if (!roomId || seatIndex === undefined) return;

    const room = liveRooms[roomId];
    if (!room) return;

    room.seats[seatIndex] = null;
    socket.leave(roomId);
    io.to(roomId).emit('roomUpdate', room);
  });

  // Mic toggle
  socket.on('toggleMic', ({ roomId, seatIndex, micOn }) => {
    io.to(roomId).emit('micToggled', { seatIndex, micOn });
  });

  // Lock/unlock seats
  socket.on('lockSeats', ({ roomId, lock }) => {
    const room = liveRooms[roomId];
    if (!room) return;
    if (lock) {
      room.lockedSeats = new Set([...Array(8).keys()]);
    } else {
      room.lockedSeats.clear();
    }
    io.to(roomId).emit('roomUpdate', room);
  });

  socket.on('disconnect', () => {
    const { roomId, seatIndex } = socket.data || {};
    if (roomId !== undefined && seatIndex !== undefined) {
      const room = liveRooms[roomId];
      if (room) {
        room.seats[seatIndex] = null;
        io.to(roomId).emit('roomUpdate', room);
      }
    }
    console.log('Client disconnected: ' + socket.id);
  });
});

// ------------------- Start Server -------------------
server.listen(PORT, () => {
  console.log(`Server with WebSocket listening on port ${PORT}`);
});
